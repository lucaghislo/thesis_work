#!/usr/bin/env python3
# coding=utf8

from abc import ABC, abstractmethod
from enum import Enum, auto


__all__ = ['OrderHierarchy', 'RedactionHierarchy', 'DataHierarchy',
           'IntervalHierarchy']
# 'DateHierarchy'


class Hierarchy(ABC):
    @abstractmethod
    def _get_config(self):
        pass

    def _validate(self, df, col):
        return True

    def __repr__(self):
        return f'<{self.__class__.__name__}: {repr(self._get_config())}>'


class BuilderHierarchy(Hierarchy):
    _conf_key = 'hierarchyBuilder'

    def _get_config(self):
        return {
            'hierarchyBuilderType': self._builder_type,
            'params': self._get_params()
        }

    def _get_params(self):
        return {}


class OrderHierarchy(BuilderHierarchy):
    '''An order hierarchy for numeric values.

    An order hierarchy works much like an interval hierarchy, breaking
    the range of values down into intervals, and merging those
    intervals at higher generalization levels. Unlike intervals, it is
    not necessary to fully specify the base intervals. Rather, the
    data will be examined and intervals generated automatically. An
    *aggregate function* will then be applied to the data, replacing
    the values as necessary.

    Valid aggregate functions are:
        * arithmetic_mean
        * bounds
        * geometric_mean
        * interval
        * prefix
        * set
        * set_of_prefixes

    Paramters
    ---------
    aggregate_function : str
        One of the aggregate functions specified above
    fanouts : iterable of int
        Index 0 specifies the base size of the bins generated, while the
        remaining indices are multiplied successively to generate the bin size
        for the next level. e.g. [10, 2, 2] means make bins of size 10, 20,
        and 40.
    '''
    _builder_type = 'ORDER'

    class _AggregateFunction(Enum):
        ARITHMETIC_MEAN = auto()
        BOUNDS = auto()
        GEOMETRIC_MEAN = auto()
        INTERVAL = auto()
        PREFIX = auto()
        SET = auto()
        SET_OF_PREFIXES = auto()
        UNKNOWN = auto()

    def __init__(self, aggregate_function, *fanout):
        try:
            self.fanout = [int(f) for f in fanout]
        except ValueError:
            raise ValueError('All fanout values must be representable as '
                             'integers')

        try:
            self.aggregate_function = OrderHierarchy._AggregateFunction[
                aggregate_function.upper()]
        except KeyError:
            raise ValueError(
                f'Invalid aggregate function {aggregate_function}, valid '
                f'values are: '
                f'{OrderHierarchy._AggregateFunction.__members__.keys()}')

    def _get_config(self):
        conf = super(OrderHierarchy, self)._get_config()
        conf['aggregateFunction'] = self.aggregate_function.name
        return conf

    def _get_params(self):
        return {'fanouts': self.fanout}


class IntervalHierarchy(BuilderHierarchy):
    '''Interval based hierarchy for numeric data.

    An interval hierarchy allows full control over the size of the hierarchies,
    including specifying heterogenous sizes, as well as heterogenous
    combinations of those hierarchies to deal with data whose distributions
    may not function well with an
    :class:`~cn.protect.hierarchy.OrderHierarchy`\\.

    Parameters
    ----------
    intervals : iterable of iterable of int
        The values of the outermost iterable contain iterables of size two,
        whose values specify the min and max of that particular interval. e.g.
        [[0, 10], [10, 20]]. Note that there must be no overlap, and all
        values in the column must be covered by the intervals.
    fanouts : iterable of iterable of int
        The fanouts specify how to combine the intervals generated by
        the previous level. A good default for the first level may be
        all 1s. The following values of the outer iterable detail how
        many of the base intervals should be spanned to generate the
        intervals for the new level.  As a result, all levels should
        sum to the number of intervals specified.  e.g. [[1, 1, 1],
        [2, 1], [3]] means there are 3 intervals, use each one for the
        first level, merge the first two and leave the third distinct
        for the second level, and merge everything for the final
        level.

    '''
    _builder_type = 'INTERVAL'

    def __init__(self, intervals=None, fanouts=None):
        self._intervals = []
        self._fanouts = []
        for i in intervals or []:
            self.add_interval(*i)
        for f in fanouts or []:
            self.add_fanout(*f)

    def add_fanout(self, *spans):
        if sum(spans) != len(self._intervals):
            raise ValueError(f'Fanouts must cover all intervals, sum of spans '
                             f'must equal count of intervals: {sum(spans)} '
                             f'!= {len(self._intervals)}')
        self._fanouts.append(list(spans))

    def add_interval(self, min, max, label=None):
        self._intervals.append({'min': min, 'max': max,
                                'label': label or f'{min}-{max}'})

    def _get_params(self):
        if not self._intervals or not self._fanouts:
            raise ValueError('Must specify at least one interval and fanout')

        return {
            'intervals': [i for i in self._intervals],
            'groups': [{'fanouts': f} for f in self._fanouts]
            }


class RedactionHierarchy(BuilderHierarchy):
    '''Redact a text column, from right-to-left by default.

    The redaction hierarchy indicates that values should be
    generalized a single character at a time in the direction
    specified. This is useful for values that get more specific as
    individual characters are removed, such as zipcodes and GPS
    coordinates.

    Parameters
    ----------
    ltr : bool
        Redact from left-to-right. Uses right-to-left by default.
    '''
    _builder_type = 'REDACTION'

    def __init__(self, ltr=False):
        self._ltr = ltr

    def _get_params(self):
        return {
            'ltr': self._ltr
            }


# class DateHierarchy(BuilderHierarchy):
#     _builder_type = 'DATE'


class DataHierarchy(Hierarchy):
    '''Use a DataFrame to explicitly define each level of the hierarchy.

    The first column will be treated as the 0th level of
    generalization, and hence must contain every unique value seen
    in the dataset. Each subsequent column defines, in order, the
    generalized value to be substituted for the original value at
    that particular level of generalization. An example
    using location information would look like:

    +----------------+------------+------------------+---------+-----------------+
    | Original       | Level 1    | Level 2          | Level 3 | Level 4         |
    +----------------+------------+------------------+---------+-----------------+
    | 123 Example St | Example St | Example Town, EX | EX      | Example Country |
    +----------------+------------+------------------+---------+-----------------+

    This would match a row with the value ``123 Example St`` and
    attempt to replace it with each subsequent value from left to
    right as higher generalization levels were explored. In order
    for this to produce meaningful results more and more rows
    should end up with identical values from left to right, such
    that the last column may only have 2 or 3 unique values
    specified.

    Parameters
    ----------
    df : Pandas DataFrame
        The data generalization hierarchy, as described above, in a Pandas
        DataFrame.
    '''
    _conf_key = 'hierarchyData'

    def __init__(self, df):
        self.df = df

    def _validate(self, df, col):
        if not df[col].isin(self.df.iloc[:, 0]).all():
            raise ValueError('Fist column of data hierarchies must contain '
                             'all unique values in column')
        return True

    def _get_config(self):
        return {'fromStream': True}
